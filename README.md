# design_pattern

使用python学习设计模式

=========================================================

## Singleton.py:单例模式

单例模式是所有设计模式中比较简单的一类，其定义如下：Ensure a class has only one instance, and provide a global point of access to it.（保证某一个类只有一个实例，而且在全局只有一个访问点）

单例模式的优点：

1. 由于单例模式要求在全局内只有一个实例，因而可以节省比较多的内存空间；
2. 全局只有一个接入点，可以更好地进行数据同步控制，避免多重占用；
3. 单例可长驻内存，减少系统开销。

单例模式的缺点：

1. 单例模式的扩展是比较困难的；
2. 赋于了单例以太多的职责，某种程度上违反单一职责原则（六大原则后面会讲到）；
3. 单例模式是并发协作软件模块中需要最先完成的，因而其不利于测试；
4. 单例模式在某种情况下会导致“资源瓶颈”。

单例模式的应用举例：

1. 生成全局惟一的序列号；
2. 访问全局复用的惟一资源，如磁盘、总线等；
3. 单个对象占用的资源过多，如数据库等；
4. 系统全局统一管理，如Windows下的Task Manager；
5. 网站计数器。

## factory.py: 工厂模式

工厂模式的定义如下：定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。

工厂模式的优点：

1. 一个调用者想创建一个对象，只要知道其名称就可以了；
2. 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以;
3. 屏蔽产品的具体实现，调用者只关心产品的接口。

工厂模式的缺点：

1. 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。

工厂模式应用举例：

1. 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

## builer.py: 建造者模式

建造者模式的定义如下：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

建造者模式的优点：

1. 封装性好，用户可以不知道对象的内部构造和细节，就可以直接建造对象；
2. 系统扩展容易；
3. 建造者模式易于使用，非常灵活。在构造性的场景中很容易实现“流水线”；
4. 便于控制细节。

建造者模式的缺点：

1. “加工工艺”对用户不透明。（封装的两面性）

建造者模式应用举例：

1. 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。

## prototype.py

原型模式定义如下：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
需要注意一点的是，进行clone操作后，新对象的构造函数没有被二次执行，新对象的内容是从内存里直接拷贝的。

原型模式的优点：

1. 性能极佳，直接拷贝比在内存里直接新建实例节省不少的资源；
2. 简化对象创建，同时避免了构造函数的约束，不受构造函数的限制直接复制对象，是优点，也有隐患，这一点还是需要多留意一些。

原型模式的缺点：

1. 深拷贝和浅拷贝的使用需要事先考虑周到；
2. 某些编程语言中，拷贝会影响到静态变量和静态函数的使用。

原型模式应用举例：

1. 对象在修改过后，需要复制多份的场景。如一些涉及到复制、粘贴的场景。

